{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$();\n\nimport { useEffect, useState, useRef, useCallback } from 'react';\nexport function useFirestoreQuery(query) {\n  _s();\n\n  const [docs, setDocs] = useState([]); // Store current query in ref\n\n  const queryRef = useRef(query); // Compare current query with the previous one\n\n  useEffect(() => {\n    var _queryRef$curent;\n\n    // Use Firestore built-in 'isEqual' method\n    // to compare queries\n    if (!(queryRef === null || queryRef === void 0 ? void 0 : (_queryRef$curent = queryRef.curent) === null || _queryRef$curent === void 0 ? void 0 : _queryRef$curent.isEqual(query))) {\n      queryRef.current = query;\n    }\n  }); // Re-run data listener only if query has changed\n\n  useEffect(() => {\n    if (!queryRef.current) {\n      return null;\n    } // Subscribe to query with onSnapshot\n\n\n    const unsubscribe = queryRef.current.onSnapshot(querySnapshot => {\n      // Get all documents from collection - with IDs\n      const data = querySnapshot.docs.map(doc => ({ ...doc.data(),\n        id: doc.id\n      })); // Update state\n\n      setDocs(data);\n    }); // Detach listener\n\n    return unsubscribe;\n  }, [queryRef]);\n  return docs;\n}\n\n_s(useFirestoreQuery, \"Re5UcHB+INAeXTC2rNtMGWgiZSw=\");\n\nexport function useAuthState(auth) {\n  _s2();\n\n  const [initializing, setInitializing] = useState(true);\n  const [user, setUser] = useState(() => auth.currentUser);\n  useEffect(() => {\n    const unsubscribe = auth.onAuthStateChanged(user => {\n      if (user) {\n        setUser(user);\n      } else {\n        setUser(false);\n      }\n\n      if (initializing) {\n        setInitializing(false);\n      }\n    }); // Cleanup subscription\n\n    return unsubscribe;\n  }, [auth, initializing]);\n  return {\n    user,\n    initializing\n  };\n}\n\n_s2(useAuthState, \"1y5OXjZSOZEq7yaIlGqOitqtnTg=\");\n\nexport function useLocalStorage(key, initialValue) {\n  _s3();\n\n  // State to store our value\n  // Pass initial state function to useState so logic is only executed once\n  const [storedValue, setStoredValue] = useState(() => {\n    try {\n      // Get from local storage by key\n      const item = window.localStorage.getItem(key); // Parse stored json or if none return initialValue\n\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      // If error also return initialValue\n      console.log(error);\n      return initialValue;\n    }\n  }); // Return a wrapped version of useState's setter function that ...\n  // ... persists the new value to localStorage.\n\n  const setValue = value => {\n    try {\n      // Allow value to be a function so we have same API as useState\n      const valueToStore = value instanceof Function ? value(storedValue) : value; // Save state\n\n      setStoredValue(valueToStore); // Save to local storage\n\n      window.localStorage.setItem(key, JSON.stringify(valueToStore));\n    } catch (error) {\n      // A more advanced implementation would handle the error case\n      console.log(error);\n    }\n  };\n\n  return [storedValue, setValue];\n}\n\n_s3(useLocalStorage, \"z0XdM4TLkDZuzSOGq1lQIVlfpgk=\");\n\nexport function useMedia(queries, values, defaultValue) {\n  _s4();\n\n  // Array containing a media query list for each query\n  const mediaQueryLists = queries.map(q => window.matchMedia(q)); // Function that gets value based on matching media query\n\n  const getValue = useCallback(() => {\n    // Get index of first media query that matches\n    const index = mediaQueryLists.findIndex(mql => mql.matches); // Return related value or defaultValue if none\n\n    return typeof values[index] !== 'undefined' ? values[index] : defaultValue;\n  }, [mediaQueryLists, values, defaultValue]); // State and setter for matched value\n\n  const [value, setValue] = useState(getValue);\n  useEffect(() => {\n    // Event listener callback\n    // Note: By defining getValue outside of useEffect we ensure that it has ...\n    // ... current values of hook args (as this hook callback is created once on mount).\n    const handler = () => setValue(getValue); // Set a listener for each media query with above handler as callback.\n\n\n    mediaQueryLists.forEach(mql => mql.addListener(handler)); // Remove listeners on cleanup\n\n    return () => mediaQueryLists.forEach(mql => mql.removeListener(handler));\n  }, [getValue, mediaQueryLists]);\n  return value;\n}\n\n_s4(useMedia, \"e+PQ5vNDHpJn//CUrGMhOOWZeEw=\");\n\nexport function useDarkMode() {\n  _s5();\n\n  // See if user has set a browser or OS preference for dark mode.\n  const prefersDarkMode = useMedia(['(prefers-color-scheme: dark)'], [true], false); // Use our useLocalStorage hook to persist state through a page refresh\n\n  const [enabled, setEnabled] = useLocalStorage('dark-mode-enabled', prefersDarkMode); // Fire off effect that add/removes dark mode class\n\n  useEffect(() => {\n    const className = 'dark';\n    const element = window.document.body;\n\n    if (enabled) {\n      element.classList.add(className);\n    } else {\n      element.classList.remove(className);\n    }\n  }, [enabled] // Only re-call effect when value changes\n  ); // Return enabled state and setter\n\n  return [enabled, setEnabled];\n}\n\n_s5(useDarkMode, \"A4e7DHAPR7cIAoKN75jTiwgtryE=\", false, function () {\n  return [useMedia, useLocalStorage];\n});","map":{"version":3,"sources":["C:/Users/Bhuvan R/Documents/GitHub/react-firechat/src/hooks.js"],"names":["useEffect","useState","useRef","useCallback","useFirestoreQuery","query","docs","setDocs","queryRef","curent","isEqual","current","unsubscribe","onSnapshot","querySnapshot","data","map","doc","id","useAuthState","auth","initializing","setInitializing","user","setUser","currentUser","onAuthStateChanged","useLocalStorage","key","initialValue","storedValue","setStoredValue","item","window","localStorage","getItem","JSON","parse","error","console","log","setValue","value","valueToStore","Function","setItem","stringify","useMedia","queries","values","defaultValue","mediaQueryLists","q","matchMedia","getValue","index","findIndex","mql","matches","handler","forEach","addListener","removeListener","useDarkMode","prefersDarkMode","enabled","setEnabled","className","element","document","body","classList","add","remove"],"mappings":"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","sourcesContent":["import { useEffect, useState, useRef, useCallback } from 'react';\r\n\r\nexport function useFirestoreQuery(query) {\r\n  const [docs, setDocs] = useState([]);\r\n\r\n  // Store current query in ref\r\n  const queryRef = useRef(query);\r\n\r\n  // Compare current query with the previous one\r\n  useEffect(() => {\r\n    // Use Firestore built-in 'isEqual' method\r\n    // to compare queries\r\n    if (!queryRef?.curent?.isEqual(query)) {\r\n      queryRef.current = query;\r\n    }\r\n  });\r\n\r\n  // Re-run data listener only if query has changed\r\n  useEffect(() => {\r\n    if (!queryRef.current) {\r\n      return null;\r\n    }\r\n\r\n    // Subscribe to query with onSnapshot\r\n    const unsubscribe = queryRef.current.onSnapshot(querySnapshot => {\r\n      // Get all documents from collection - with IDs\r\n      const data = querySnapshot.docs.map(doc => ({\r\n        ...doc.data(),\r\n        id: doc.id,\r\n      }));\r\n      // Update state\r\n      setDocs(data);\r\n    });\r\n\r\n    // Detach listener\r\n    return unsubscribe;\r\n  }, [queryRef]);\r\n\r\n  return docs;\r\n}\r\n\r\nexport function useAuthState(auth) {\r\n  const [initializing, setInitializing] = useState(true);\r\n  const [user, setUser] = useState(() => auth.currentUser);\r\n\r\n  useEffect(() => {\r\n    const unsubscribe = auth.onAuthStateChanged(user => {\r\n      if (user) {\r\n        setUser(user);\r\n      } else {\r\n        setUser(false);\r\n      }\r\n      if (initializing) {\r\n        setInitializing(false);\r\n      }\r\n    });\r\n\r\n    // Cleanup subscription\r\n    return unsubscribe;\r\n  }, [auth, initializing]);\r\n\r\n  return { user, initializing };\r\n}\r\n\r\nexport function useLocalStorage(key, initialValue) {\r\n  // State to store our value\r\n  // Pass initial state function to useState so logic is only executed once\r\n  const [storedValue, setStoredValue] = useState(() => {\r\n    try {\r\n      // Get from local storage by key\r\n      const item = window.localStorage.getItem(key);\r\n      // Parse stored json or if none return initialValue\r\n      return item ? JSON.parse(item) : initialValue;\r\n    } catch (error) {\r\n      // If error also return initialValue\r\n      console.log(error);\r\n      return initialValue;\r\n    }\r\n  });\r\n\r\n  // Return a wrapped version of useState's setter function that ...\r\n  // ... persists the new value to localStorage.\r\n  const setValue = value => {\r\n    try {\r\n      // Allow value to be a function so we have same API as useState\r\n      const valueToStore =\r\n        value instanceof Function ? value(storedValue) : value;\r\n      // Save state\r\n      setStoredValue(valueToStore);\r\n      // Save to local storage\r\n      window.localStorage.setItem(key, JSON.stringify(valueToStore));\r\n    } catch (error) {\r\n      // A more advanced implementation would handle the error case\r\n      console.log(error);\r\n    }\r\n  };\r\n\r\n  return [storedValue, setValue];\r\n}\r\n\r\nexport function useMedia(queries, values, defaultValue) {\r\n  // Array containing a media query list for each query\r\n  const mediaQueryLists = queries.map(q => window.matchMedia(q));\r\n\r\n  // Function that gets value based on matching media query\r\n  const getValue = useCallback(() => {\r\n    // Get index of first media query that matches\r\n    const index = mediaQueryLists.findIndex(mql => mql.matches);\r\n    // Return related value or defaultValue if none\r\n    return typeof values[index] !== 'undefined' ? values[index] : defaultValue;\r\n  }, [mediaQueryLists, values, defaultValue]);\r\n\r\n  // State and setter for matched value\r\n  const [value, setValue] = useState(getValue);\r\n\r\n  useEffect(() => {\r\n    // Event listener callback\r\n    // Note: By defining getValue outside of useEffect we ensure that it has ...\r\n    // ... current values of hook args (as this hook callback is created once on mount).\r\n    const handler = () => setValue(getValue);\r\n    // Set a listener for each media query with above handler as callback.\r\n    mediaQueryLists.forEach(mql => mql.addListener(handler));\r\n    // Remove listeners on cleanup\r\n    return () => mediaQueryLists.forEach(mql => mql.removeListener(handler));\r\n  }, [getValue, mediaQueryLists]);\r\n\r\n  return value;\r\n}\r\n\r\nexport function useDarkMode() {\r\n  // See if user has set a browser or OS preference for dark mode.\r\n  const prefersDarkMode = useMedia(\r\n    ['(prefers-color-scheme: dark)'],\r\n    [true],\r\n    false\r\n  );\r\n\r\n  // Use our useLocalStorage hook to persist state through a page refresh\r\n  const [enabled, setEnabled] = useLocalStorage(\r\n    'dark-mode-enabled',\r\n    prefersDarkMode\r\n  );\r\n\r\n  // Fire off effect that add/removes dark mode class\r\n  useEffect(\r\n    () => {\r\n      const className = 'dark';\r\n      const element = window.document.body;\r\n      if (enabled) {\r\n        element.classList.add(className);\r\n      } else {\r\n        element.classList.remove(className);\r\n      }\r\n    },\r\n    [enabled] // Only re-call effect when value changes\r\n  );\r\n\r\n  // Return enabled state and setter\r\n  return [enabled, setEnabled];\r\n}\r\n"]},"metadata":{},"sourceType":"module"}